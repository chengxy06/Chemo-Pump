#!/usr/bin/env ruby
#require "profile" #使用这个库可以分析性能
#require 'benchmark' #通过以下语句可以测试代码运行时间: Benchmark.measure {运行代码 }

#添加系统中的库
require 'optparse' #这个库可以分析命令行参数
require 'ostruct'  #这个库可以创建结构体
require 'fileutils'
require 'roo'

#文件名字
self_name = File.basename(__FILE__, ".rb")

#帮助信息
help_str = %Q{This is used to generate c code for string of all language.
Usage: #{self_name} [option] file1	}

#初始化所有option
$options = OpenStruct.new
$options.out_file_name = nil   #输出文件名字
$options.out_file_name_of_id = nil   #输出文件名字
$options.in_file_name = nil  #所要处理的文件名

begin
	#解析option,
	OptionParser.new do |opts|
		#设置程序的帮助信息
		opts.banner = help_str
		#设置程序的版本信息
		opts.version = "1.0.0"
		#设置帮助里的输出信息
		#opts.separator ""
		sample_str = %Q{#{self_name} lang.xlsx  #it will generate generated_string_data.h and generated_string_id.h}

		#帮助信息
        opts.on_tail("-h", "--help", "show help message") do
            puts opts
            puts("Example:")
            puts sample_str
            exit
        end

        opts.on("-o", "--out=out_file",
		"output to this file") do |file_name|
			$options.out_file_name = file_name
		end

		opts.on("-i", "--id_out=out_file_for_id_define",
		"output id definition to this file") do |file_name|
			$options.out_file_name_of_id = file_name
		end

	end.parse!
rescue OptionParser::ParseError =>err #命令行参数输入出错
	#输出错误信息并退出
	CommonOptionParser.param_error err  #也可以使用全局变量$!代替err
end


#function define
def exit_p str
	puts str
	exit -1
end

#return {section=>{key=>value,...},...
def read_ini_file ini_file
	section = {}
	last_section = ""
	section[last_section]={}
	File.open ini_file,"r:bom|utf-8" do |file|
		file.each_line do |line|
			if line[0] == ';' || line[0] == '\n'
				next
			end
			str = line.strip
			if str =~ /^\[(.*)\]/
				last_section = $1
				section[last_section] = {}
			#get key and value
			elsif str =~ /(\w+)=(.*)/
				key = $1
				value = $2
				section[last_section][key]=value
			else
				key = str
				value = nil
				section[last_section][key]=value
			end
		end
	end		

	return section
end


def generate_language_string outfile, sheet, column, language_name
	outfile.puts "const static StringData g_string_data_#{language_name}[] = \n{"
	2.upto(sheet.last_row) do |row|
		#get row 2  and column i
		id = sheet.cell(row, 1)
		utf8_str = sheet.cell(row, column).to_s
		if utf8_str
			str = ""
			is_need_escaped = false
			utf8_str.each_byte do |c|
				if is_need_escaped
					is_need_escaped = false
					case c
					when 'n'.ord
						c = "\n".ord
					when 'r'.ord
						c = "\r".ord
					when 't'.ord
						c = "\t".ord
					end
				elsif c == "\\".ord
					is_need_escaped = true
					next
				end
				str+= "\\x%x" %(c.ord)
			end
			outfile.puts "\t{kStr#{id}, \"#{str}\"},"
		else
			outfile.puts "\t{kStrNull, \"\"},"
		end
	end

	outfile.puts "};"
	outfile.puts ""
end

#将下划线命名法转换为驼峰命名法
def under_score_case_to_camel_case str
	words=str.split('_')
	new_words = words.map { |e|  e.capitalize}
	return new_words.join()
end
#main

#check parameters
if(ARGV.size == 0)
	exit_p "no input file"
else
	$options.in_file_name = ARGV[0]
end

#open outfile for write
out_file_name = "generated_string_data.h"
out_file_name_of_id = "generated_string_id.h"
lang_ini_file = "#{File.dirname($options.in_file_name)}/lang.ini"
#p $options.in_file_name
#p File.dirname($options.in_file_name)
if $options.out_file_name
	out_file_name = $options.out_file_name
end

if $options.out_file_name_of_id
	out_file_name_of_id = $options.out_file_name_of_id
end

#read valid lang
valid_langs = []
sections = read_ini_file(lang_ini_file)
valid_langs = sections[""]["lang"].split(',')

outfile = File.open out_file_name,"w"
outfile_for_head = File.open out_file_name_of_id,"w"

begin
	#read excel file
	excel = Roo::Excelx.new($options.in_file_name.gsub('\\','/'))  
rescue Exception => e
	exit_p("#{$options.in_file_name} not exist or format is wrong, detail error:[#{e}]")
end

sheet0 = excel.sheet(0)
outfile.puts "//generated by #{self_name}, donot edit it"
#check each column of row 2 to check if is valid
3.upto(sheet0.last_column) do |column|
	#get the language name and check if it is valid
	if valid_langs.index sheet0.cell(1, column)
		#generate the lanuage code
		generate_language_string(outfile, sheet0, column, sheet0.cell(1, column))
	end
end

#output g_lang_string_data
outfile.puts "const static LangStringData g_lang_string_data[] = \n{"
valid_langs.each do |lang_name|
	outfile.puts "\t{kSszLang#{under_score_case_to_camel_case(lang_name)}, g_string_data_#{lang_name}},"
end
outfile.puts "};"
outfile.puts ""
outfile.close

#output string id define 
outfile_for_head.puts "//generated by #{self_name}, donot edit it"
outfile_for_head.puts "typedef enum\n{"
2.upto(sheet0.last_row) do |row|
	#get column 1
	id = sheet0.cell(row, 1)
	outfile_for_head.puts "\tkStr#{id},"	
end
outfile_for_head.puts "\tDYNAMIC_STRING_ID_DEFINE,\n\tkStrIDMax\n}StrID;"
outfile_for_head.close
