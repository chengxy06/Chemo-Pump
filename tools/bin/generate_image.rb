#!/usr/bin/env ruby
#require "profile" #使用这个库可以分析性能
#require 'benchmark' #通过以下语句可以测试代码运行时间: Benchmark.measure {运行代码 }

#添加系统中的库
#require 'fileutils'
require 'pathname'

#将../lib添加到库路径
$LOAD_PATH<<(File.expand_path('../', File.dirname(__FILE__))+"/lib")

#添加同目录的库
#下面的库可以分析一些共同的命令行参数以及添加一些通用的函数等
if File.file? File.dirname(__FILE__)+"/"+"main_common.rb"
	require_relative "main_common"  
else
	#如果同目录下没有就试试系统库$LOAD_PATH
	require 'main_common'
end

#设置帮助,版本等信息
SELF_NAME = File.basename(__FILE__)
SELF_ABSOLUTE_PATH = Pathname.new(__FILE__).realpath #File.expand_path(SELF_NAME)
SELF_DIR = File.dirname(SELF_ABSOLUTE_PATH)
HELP_STR = %Q{This is used to generate code from the img
Usage: #{SELF_NAME} [option]... <file>...	
Note: <file> can use wildcard, #{CommonOptionParser::WILDCARD_USE_HELP}}
EXAMPLE_STR = %Q{Example:
#{SELF_NAME} file1 file2 
#{SELF_NAME} :file* 
#{SELF_NAME} 'file*' }		
VERSION_STR = "1.0.0"
ERROR_INFO_WHEN_NO_IN_ARG = "no input file"
IMG2LCD_BIN_PATH = "ruby #{SELF_DIR}/img2lcd.rb"


#初始化所有option
$options = OpenStruct.new
$options.out_file_name = nil   #输出文件名字, 如果不定义此变量,则命令选项-o,--outfile没有
#$options.error_out_file_name = nil   #错误输出文件名字,如果不定义此变量,则命令选项--error-outfile没有
$options.list_file_name = nil  #包含文件/目录名列表的文件名字,在列表中的文件/目录名不能包含通配符,也不能递归查找,
								#如果不定义此变量,则命令选项--listfile没有
$options.is_recursive = nil  #是否也处理在子目录中的输入文件,如果不定义此变量,则命令选项-r,--recursive没有
$options.is_allow_wildcard = true #是否允许参数为通配符
$options.action_when_no_normal_arg = "help" #当没有普通参数时的动作,"error":报错, "help":打印帮助,nil:正常
$options.is_use_stdin_as_inputfile = nil #是否从stdin读取输入内容,如果不定义此变量,则命令选项--from-stdin没有
$options.normal_args = []  #所要处理的输入参数(此参数数组中不包含options,参数可能是文件,目录名或其他)
#其他选项
$options.code_out_dir = nil

#配置选项并根据选项解析参数
#根据$options的值添加选项: -o, --outfile=<file>,--error-outfile=<file>, --listfile=<file>,
#	       -r,--recursive,-h,--help,-v,--version
CommonOptionParser.analyze_opt($options, HELP_STR, EXAMPLE_STR, VERSION_STR, ERROR_INFO_WHEN_NO_IN_ARG) do |opts|
	#添加自定义的选项
	# # 第一项是Short option，第二项是Long option，第三项是对Option的描述
	# opts.on("-w", "--warn-file=<file>",
	# "output warn to this file") do |file_name|
	# 	$options.out_file_name = file_name
	# 	CommonOptionParser.param_error "name is not right"
	# end
	# 
    opts.on("-d", "--directory=out_dir",
	"output code to this dir") do |file_name|
		$options.code_out_dir = file_name
	end
end

#函数定义

#将下划线命名法转换为驼峰命名法
def under_score_case_to_camel_case str
	words=str.split('_')
	new_words = words.map { |e|  e.capitalize}
	return new_words.join()
end


class ImageCode
	attr:height
	attr:width
	attr:bytes #字模数组
	attr:byte_count_of_one_line
	attr:img_name
	attr:img_type
	attr:bits_per_pixel

	def init_from_bmp bmp_path,is_scan_row=true,is_little_endian=true
		@img_name = File.basename(bmp_path,".*")
		@img_type = File.extname(bmp_path)

		cmd = "#{IMG2LCD_BIN_PATH} "
		if !is_scan_row
			cmd += "--column_scan "
		end
		if !is_little_endian
			cmd += "--big_endian "
		end
		cmd += bmp_path
		#puts cmd
		ret = `#{cmd}`
		if $? !=0
			puts "Run #{cmd} fail"
			exit -1
		end
		ret.each_line do |line|
			line.chomp!
			if line =~ /size=(\d+)x(\d+)/
				@width = $1.to_i
				@height = $2.to_i
			elsif line =~ /bit_count=(\d+)/
				@bits_per_pixel = $1
			elsif line.include?("code=")
				@bytes = line[5..-1].split(",")
				break
			end
		end
		@byte_count_of_one_line = @bytes.size/@height
	end

end

#将字节转换为类似于XXXXXXXX,_XX_____的字符串
def convert_byte_to_XXX(byte)
	binary_str = "%8s" % byte.to_s(2)
	ret = ""
	binary_str.each_char do |ch|
		if ch == " " || ch == "0"
			ret += "_"
		else
			ret += "X"
		end
	end

	return ret
end
#检查参数
if(ARGV.size == 0)
	exit_p "no input directory"
else
	$options.in_file_name = ARGV[0]
end


$img_codes = []
#处理所有普通输入参数
#num:当前处理的是第几个,  arg:当前处理的参数的名字(可能是文件,目录或其他)
#out_file:输出文件,已经打开 	其中如果输出文件名$options.out_file_name是nil那就是使用了终端$stdout
#error_file:错误输出文件,已经打开 其中如果错误输出文件名$options.error_file_name是nil那就是使用了终端$stderr
#另外out_file和error_file可以在each_file函数中传入,例CommonOptionParser.each_file($options, $stdout, $stderr) ...
CommonOptionParser.each_arg() do |num, arg, out_file, error_file|
	#puts Benchmark.measure{
	ch = File.basename(arg,".*").to_i(16)
	img_code = ImageCode.new
	#逐行模式,顺向
	img_code.init_from_bmp arg,true, false
	$img_codes << img_code

	#}
end

#输出代码
code_out_dir = $options.code_out_dir
if !code_out_dir
	code_out_dir = ""
elsif !Dir.exist?(code_out_dir)
	Dir.mkdir(code_out_dir)
end

var_name_prefix = "g_img_"
$img_codes.each do |img_code|
	outfile = File.open code_out_dir+"/"+img_code.img_name+".c","w"
	outfile.puts "//generated by #{SELF_NAME}, donot edit it"
	outfile.puts "#include \"constant_byte_define.h\" "
	outfile.puts "const unsigned char #{var_name_prefix}#{img_code.img_name}[]= {"

	img_code.bytes.each_with_index do |ch,index|
		if index != 0 && index%img_code.byte_count_of_one_line==0
			#需要换行
			outfile.puts
		end

		outfile.print convert_byte_to_XXX(ch.to_i(16))+","
	end
	outfile.puts "\n};"
	outfile.puts
	outfile.close
end


#write generated_image_data.h
outfile = File.open "generated_image_data.h","w"
outfile.puts "//generated by #{SELF_NAME}, donot edit it"
#genarate var define
$img_codes.each do |img_code|
	outfile.puts "extern unsigned char #{var_name_prefix}#{File.basename(img_code.img_name,'.*')}[];"
end
outfile.puts
outfile.puts "const static Image g_image_data[] =\n{"
$img_codes.each do |img_code|
	outfile.print "\t{#{var_name_prefix}#{File.basename(img_code.img_name,'.*')}, "
	outfile.print "#{img_code.width}, #{img_code.height}, #{img_code.byte_count_of_one_line}, #{img_code.bits_per_pixel}"
	outfile.puts "},"
end
outfile.puts "};"
outfile.close

#write generated_image_id.h
outfile = File.open "generated_image_id.h","w"
outfile.puts "//generated by #{SELF_NAME}, donot edit it"
outfile.puts "typedef enum\n{"
$img_codes.each() do |img_code|
	outfile.puts "\tkImg#{under_score_case_to_camel_case(File.basename(img_code.img_name,'.*'))},"
end
outfile.puts "\tkImgIDMax,\n }ImgID;"
outfile.close

